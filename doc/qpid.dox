/*! @page qpid_desc Closed-loop PID Controller
* @tableofcontents
* A PID controller seeks to keep some input variable close to a desired setpoint
* by adjusting an output. The way in which it does this can be 'tuned' by 
* adjusting three parameters (Proportional, Integral, Derivative).
*
* qLibs provides the \ref qpid implementation, which, apart from the simplified 
* overview representation of the PID controller, also addresses some practical
* issues and includes additional features as listed below:
* 
* - Noisy Derivative Contributions (Derivative filter)
* - Automatic Anti-windup control
* - Bumpless transfer
* - Auto-tunning
* - Additive MRAC
*
*
* @section qpid_approach PID Controller approach
*
* The mathematical model and practical loop uses a direct control 
* action for all the PID terms, which means an increasing positive error 
* results in an increasing positive control output correction.
*
* The overall control function implemented by \ref qpid is given by:
*
* <center>
* \f$ v(t)= \psi(t)r(t) + [ K_{c}e(t) + K_{i}\int [ e(t) + c(t-1) ]dt + K_{d}f_{d}(t) ] \f$ 
*
* \f$ u(t) = \text{Sat}[ v(t), u_{min}, u_{max} ]\f$ 
*
* </center>
* where \f$r(t)\f$ the set-point, \f$ e(t) = r(t) - y(t) \f$ its the error
* \f$y(t)\f$ the process output, \f$K_{c},K_{i},K_{d}\f$ the PID gain respectively 
*  and \f$u(t)\f$ the control action.
*
* <center> \f$\psi(t)\f$ the adaptive gain from the additive MRAC (later explained) </center>
*
* As shown above, the derivative term \f$ f_{d}(t)\f$ is the output of a 
* low-pass filter who take the error derivative as input.
*
* <center> \f$ f_{d}(t) = \text{LPF}[ \frac{de(t)}{dt} ]\f$  </center>
*
* and \f$ c(t)\f$, the Anti-Windup and tracking mode feedback, with \f$K_{w}\f$
* and \f$K_{T}\f$ as the ajustment parameters respectively.
*
* <center> \f$ c(t) = K_{w}[ u(t) - v(t) ] + K_{T}[ r_{t}(t) - u(t) ]\f$ </center>
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>qpid</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-24T01:29:47.743Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;l_UB2ieVu22joh9zjSAE\&quot; version=\&quot;20.5.0\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;Y54Sw13SpVrxC9X4pJjL\&quot; name=\&quot;PÃ¡gina-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>PID Implementation</em>
* </center>
*
* @section qpid_create Creating a PID Controller
*
* Before you start using a controller, it must be instantiated first
* via the \ref qPID_controller_t type and then configured using the \ref qPID_Setup() API, 
* where you can define the PID gains and time step.
*
*  Example: Instantiating an configuring a PID controller:
*  @code{.c}
*  qPID_controller_t control;
*  const float kc = 1.0f, ki = 0.1f, kd = 0.0f;
*  const float dt = 0.01f; // time-step of 10mS
*  int ret;
*
*  ret = qPID_Setup( &control, kc, ki, kd, dt );
*  if ( 0 == ret ) {
*      // error, pid controller cant be configured
*  }
*  @endcode
*
*
*  @section qfpid_usage Usign the controller
*
*  The following example illustrates how a PID controller can be used to regulate
*  the speed of a DC motor. PID control operates on a separate task running  
*  periodically  at a rate of 50mS. The speed measurement is being read through
*  an analog input and then scaled to the appropriate units (RPM). The \ref qPID_Control() 
*  function will be in charge of computing the control action and  updating the internal
*  states of the controller. Then, the control output gets scaled-back in order to
*  send the control command by using the PWM(Pulse Width Modulation) module. 
*
*  @subsection qpid_ex1 Example: Speed control using a PID controller:
*  @code{.c}
*  #include <stdio.h>
*  #include <stdlib.h>
*  #include "freertos/FreeRTOS.h"
*  #include "freertos/task.h"
*  #include "bsp.h"
*  #include "qpid.h"
*  
*  const TickType_t  dt = 50; //50mS time-step
*  void xTaskPIDspeedControl( void *arg );
*  float SetPoint = 300.0f; // desired motor speed 300rpm
*  
*  void xTaskPIDspeedControl( void *arg )
*  {
*      qPID_controller_t *controller = (qPID_controller_t *)arg;
*      float processMeasurement;
*      float controlOutput;
*      for ( ;; ) {
*          processMeasurement = BSP_ScaletoSpeed ( BSP_AnalogRead( BSP_AI_SPEED_CHANNEL ) );
*          controlOutput = qPID_Control( controller, SetPoint, processMeasurement );
*          BSP_PWMSet( BSP_AO_SPEED_PWM_CHANNEL, BSP_ScaletoPWM( controlOutput ) ); 
*          vTaskDelay( dt / portTICK_RATE_MS) ;
*      }
*  }
*  
*  int main( int argc, char *argv[] ) 
*  {
*      qPID_controller_t speedControl;
*      int ret;
*      
*      BSP_SystemInit();
*      ret = qPID_Setup( &speedControl, 1, 0.1, 0, (float)dt/1000.0f );
*      if ( 0 == ret ) {
*          puts( "ERROR: Cant configure PID controller" );
*      }
*      qPID_SetSaturation( &speedControl, 0.0f, 100.0f );
*      // Create the task that handles the speed control at the defined rate
*      xTaskCreate( xTaskPIDspeedControl, "speedControl", 1024, &speedControl, configMAX_PRIORITIES - 1 ,NULL );
*      vTaskStartScheduler();
*      for( ;; );
*      return EXIT_SUCCESS;
*  }
*  @endcode
*
*
* @section qpid_mrac Additive MRAC (Model Reference Adaptive Control)
*
* Model Reference Adaptive Control (MRAC) is a strategy where the controller 
* of the closed-loop is adapted by an adjustment mechanism, which takes \f$ y_{m}(t) \f$ 
* from a reference model as input and tries to adjust the controller output \f$v(t)\f$. 
* The adjustment mechanism used by \ref qpid is the enhanced MIT-rule approach,
* which adapts a feed-forward gain by the error between the system \f$ y(t) \f$
* and a reference model \f$ y_{m}(t) \f$, therefore is the so-called Gradient approach.
*
* <center>
* \f$ e_{m}(t) = y(t) - y_{m}(t)\f$ 
*
* \f$ \delta(t) = -\gamma  \frac{ e_{m}(t) y_{m}(t) }{ \beta + y_{m}^{2}(t)  }  \f$ 
* </center>
*
* where \f$\gamma(t)\f$ is the adaptation gain and \f$\beta(t)\f$ is introduced 
* to remove the problem of the possible division by zero if \f$y_{m}^{2}(t) \f$
* gets too small. 
*
* The MRAC adaptation is then computed by integrating the \f$\delta(t)\f$ term 
* as follows:
*
* <center> \f$ \psi(t) = \int \delta(t) dt \f$ </center>
*
* This method can be used to adapt to slower changes but can become unstable for
* abrupt changes to the system. Therefore, this implementation uses a so called 
* modified MRAC (M-MRAC) where the adaptation is later added to a PID controller, 
* being the MRAC the additive loop.
* 
* Abrupt changes to the system are absorbed by the  PID controller, while the 
* change of the dynamics will still be handled by the MIT gain \f$\psi(t)\f$. 
* This results in the equation of the control function presented at the 
* beginning of this section.
*
* To use the additive MRAC, you should first instantiate a reference model and 
* then, enable the MRAC by using the \ref qPID_SetMRAC() API. Here, you must provide
* a pointer to the output of the reference model and the adaptation gain \f$\gamma(t)\f$
*
*  @subsection qpid_ex2 Example: Speed control with PID controller with an additive MRAC:
*  @code{.c}
*  #include <stdio.h>
*  #include <stdlib.h>
*  #include "freertos/FreeRTOS.h"
*  #include "freertos/task.h"
*  #include "bsp.h"
*  #include "qpid.h"
*  #include "qltisys.h" //to create the reference model
*  
*  #define REF_MODEL_ORDER   ( 1 )
*
*  const TickType_t dt = 50; //50mS time-step
*  void xTaskPIDspeedControl( void *arg );
*  
*  void xTaskPIDspeedControl( void *arg )
*  {
*      qPID_controller_t *controller = (qPID_controller_t *)arg;
*      qLTISys_t ref_model;
*      float num[ REF_MODEL_ORDER+1 ] = { 0.0f, 1.0f, };
*      float den[ REF_MODEL_ORDER+1 ] = { 3.0f, 1.0f, };
*      float processMeasurement;
*      float SetPoint = 300.0f; // desired motor speed 300rpm
*      float refmodel_output = 0.0f;
*      float controlOutput = 0.0f;
*
*      qLTISys_Setup( &ref_model, num, den, x, 0, REF_MODEL_ORDER+1, (float)dt/1000.0f ) );
*      qPID_SetMRAC( controller, &refmodel_output, 0.01f );
*      for ( ;; ) {
           refmodel_output = qLTISys_Excite( &ref_model, controlOutput );
*          processMeasurement = BSP_ScaletoSpeed ( BSP_AnalogRead( BSP_AI_SPEED_CHANNEL ) );
*          controlOutput = qPID_Control( controller, SetPoint, processMeasurement );
*          BSP_PWMSet( BSP_AO_SPEED_PWM_CHANNEL, BSP_ScaletoPWM( controlOutput ) ); 
*          vTaskDelay( dt / portTICK_RATE_MS) ;
*      }
*  }
*  
*  int main( int argc, char *argv[] ) 
*  {
*      qPID_controller_t speedControl;
*      int ret;
*      
*      BSP_SystemInit( );
*      ret = qPID_Setup( &speedControl, 1, 0.1, 0, (float)dt/1000.0f );
*      if ( 0 == ret ) {
*          puts( "ERROR: Cant configure PID controller" );
*      }
*      qPID_SetSaturation( &speedControl, 0.0f, 100.0f );
*      // Create the task that handles the speed control at the defined rate
*      xTaskCreate( xTaskPIDspeedControl, "speedControl", 1024, &speedControl, configMAX_PRIORITIES - 1 ,NULL );
*      vTaskStartScheduler();
*      for( ;; );
*      return EXIT_SUCCESS;
*  }
*  @endcode
*
* @section qpid_autotune Autotunning
*
* Autotuning can eliminate much of the trial and error of a manual tuning 
* approach, especially if you do not have a lot of loop tuning experience. 
* Performing the autotuning procedure will get the tuning parameters close to 
* their optimal values, but additional manual tuning may be required to get 
* the tuning parameters to their optimal values.
*
* The Autotune feature for the controller will only run for a limited amount of time
* after it gets enabled. In other words, autotuning does not run continuously 
* during operation. Whenever there is a substantial change in the process 
* dynamics, the tuning process will need to be repeated in order to derive new 
* gains required for optimal control.
*
* Autotunning is performed by using the following recursive algorithm:
*
* <center>
* \f$ L(t) =  \frac{ P(t-1)\phi }{ \lambda + \phi^{T}P(t-1)\phi  } \f$
*
* \f$\theta(t) = \theta(t-1) + L[ y(t) - \phi^{T}\theta(t)  ] \f$
*
* \f$ P(t) = \lambda^{-1}[ I - L(t)+\phi^{T}]P(t-1) \f$
*
* \f$ \theta(t) = \begin{bmatrix} \theta_{1}(t) & \theta_{2}(t) \end{bmatrix}^T  \f$ 
* and \f$ \phi(t) = \begin{bmatrix} -y(t-1) & u(t-1) \end{bmatrix}^T  \f$ 
*
* \f$ g(t) = \frac{ (1 - \mu)\theta_{2}(t) }{ 1 + \theta_{1} } + \mu g(t-1)  \f$
*
* \f$ \tau(t) = \frac{ ( \mu - 1 )dt }{ ln( |\theta_{1}| ) } + \mu \tau(t-1)  \f$
*
* \f$ K_{c}(t) = \alpha \frac{ r_{2} \tau(t) }{ g(t)dt } \f$
*
* \f$ K_{i}(t) = \alpha \frac{ g(t)[ 0.54 + 0.33r_{1} ] }{ r_{2}dt } \f$
*
* \f$ K_{c}(t) = \alpha \frac{ K_{c}(t)dt }{ r_{2} } \f$
* </center>
*
* where  \f$ r_{1} = dt/\tau(t) \f$  and \f$ r_{2} = 1.35 + 0.25r_{1} \f$ 
*
* and the remaining parameters \f$\mu\f$, \f$\alpha\f$, \f$\lambda\f$ are internally
* computed for best performance.
*
* @subsection qpid_autotune_usage Autotunning Usage
*
* In order to use the autotuner, you must first instantiate the \ref qPID_AutoTunning_t
* object and bind it to a previously configured PID controller by using the 
* \ref qPID_BindAutoTunning().
*
* After this, you can enable auto tuning via \ref qPID_EnableAutoTunning() 
* for a defined number of intervals. When the autotune ends, the resulting PID
* gains will be applied to the bounded controller.
* 
* @subsection qpid_ex3 Example: Speed control with PID controller and autotunning:
* This example takes avantage of the FreeRTOS task notifications to enable the
* autotunningm when a rising-edge is detected on a certain digital input. Autotuning
* is enabled for 5 sec. Note that the setpoint is briefly modified during this 
* process to stimulate the process. Upon completion, the setpoint is restored to 
* its original value.
*
*  @code{.c}
*  #include <stdio.h>
*  #include <stdlib.h>
*  #include "freertos/FreeRTOS.h"
*  #include "freertos/task.h"
*  #include "bsp.h"
*  #include "qpid.h"
*  
*  #define REF_MODEL_ORDER   ( 1 )
*
*  const TickType_t dt = 50; //50mS time-step
*  void xTaskPIDspeedControl( void *arg );
*  TaskHandle_t pid_task;
*  
*  void gpio_Int_Handler( void ) 
*  {
*      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
*
*      vTaskNotifyGiveFromISR( pid_task, &xHigherPriorityTaskWoken);
*      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
*      HAL_GPIO_ClearStatusFlag();
*  }
*
*  void xTaskPIDspeedControl( void *arg )
*  {
*      qPID_controller_t *controller = (qPID_controller_t *)arg;
*      float processMeasurement;
*      float SetPoint = 300.0f; // desired motor speed 300rpm
*      float tmpSetPoint = 320.0f;
*      float *p_setpoint  = &SetPoint;  
*      float refmodel_output = 0.0f;
*      float controlOutput = 0.0f;
*      uint32_t notification_autotune_enable;
*
*      qLTISys_Setup( &ref_model, num, den, x, 0, REF_MODEL_ORDER+1, (float)dt/1000.0f ) );
*      qPID_SetMRAC( controller, &refmodel_output, 0.01f );
*      for ( ;; ) {
*          notification_autotune_enable = ulTaskNotifyTake( pdTRUE, 0 ); // dont wait
*          if ( notification_autotune_enable ) {
*              p_setpoint = &tmpSetPoint; 
*              qPID_EnableAutoTunning( controller, 100 ); //enable for 5 seconds ( 100*50mS )
*          }
*          if ( qPID_AutoTunningComplete( controller) ) {
*              p_setpoint = &SetPoint;
*              qPID_EnableAutoTunning( controller, 0uL ); //disable
*          }
*          processMeasurement = BSP_ScaletoSpeed ( BSP_AnalogRead( BSP_AI_SPEED_CHANNEL ) );
*          controlOutput = qPID_Control( controller, *p_setpoint, processMeasurement );
*          BSP_PWMSet( BSP_AO_SPEED_PWM_CHANNEL, BSP_ScaletoPWM( controlOutput ) ); 
*          vTaskDelay( dt / portTICK_RATE_MS) ;
*      }
*  }
*  
*  int main( int argc, char *argv[] ) 
*  {
*      qPID_controller_t speedControl;
*      qPID_AutoTunning_t at;
*      int ret;
*      
*      BSP_SystemInit( );
*      HAL_GPIO_Enable( GPIO12, GPIO_INPUT );
*      HAL_GPIO_SetInterruptMode( GPIO12, RISING_EDGE );
*      HAL_GPIO_EnableInterrupts( );
*      ret = qPID_Setup( &speedControl, 1, 0.1, 0, (float)dt/1000.0f );
*      if ( 0 == ret ) {
*          puts( "ERROR: Cant configure PID controller" );
*      }
*      qPID_SetSaturation( &speedControl, 0.0f, 100.0f );
*      qPID_BindAutoTunning( &speedControl, &at );
*      // Create the task that handles the speed control at the defined rate
*      xTaskCreate( xTaskPIDspeedControl, "speedControl", 1024, &speedControl, configMAX_PRIORITIES - 1 , &pid_task );
*      vTaskStartScheduler();
*      for( ;; );
*      return EXIT_SUCCESS;
*  }
*  @endcode
*/